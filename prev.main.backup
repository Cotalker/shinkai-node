#[macro_use]
extern crate serde;

use prost::Message as ProstMessage;
// use prost_types::FileDescriptorSet;
use prost_reflect::{DynamicMessage, DescriptorPool, FieldDescriptor};
use std::collections::HashMap;
use serde::{Serialize, Deserialize};
use serde_json;

#[derive(Debug, Serialize, Deserialize)]
struct Msg {
    body: Body,
    encryption: String,
    external_metadata: ExternalMetadata,
}
#[derive(Debug, Serialize, Deserialize)]
struct Body {
    content: String,
    internal_metadata: InternalMetadata,
    topic: Topic,
}

#[derive(Debug, Serialize, Deserialize)]
struct InternalMetadata {
    message_schema_type: String,
}

#[derive(Debug, Serialize, Deserialize)]
struct Topic {
    topic_id: String,
    channel_id: String,
}

#[derive(Debug, Serialize, Deserialize)]
struct ExternalMetadata {
    sender: String,
    recipient: String,
    scheduled_time: String,
    signature: String,
}

pub struct MessageHandler {
    descriptor_pool: DescriptorPool,
}

#[derive(Debug)]
pub enum MessageHandlerError {
    MessageTypeNotFound,
    DecodingError(prost::DecodeError),
    JsonParsingError(serde_json::Error),
}

impl MessageHandler {
    pub fn new() -> Self {
        MessageHandler {
            descriptor_pool: DescriptorPool::new(),
        }
    }

    pub fn add_message_type(&mut self, message_type_name: &str) {
        let mut fields = HashMap::new();
        fields.insert(1, FieldDescriptor {
            name: "type".into(),
            number: 1,
            ..Default::default()
        });
        fields.insert(2, FieldDescriptor {
            name: "data".into(),
            number: 2,
            ..Default::default()
        });
        self.descriptor_pool.add_message(message_type_name, fields).unwrap();
    }

    pub fn deserialize(&self, serialized_json: &str) -> Result<Msg, MessageHandlerError> {
        let message: Msg = serde_json::from_str(serialized_json).map_err(MessageHandlerError::JsonParsingError)?;

        // Get the message type
        let message_type = &message.body.internal_metadata.message_schema_type;

        // Get the message descriptor
        let message_descriptor = self.descriptor_pool.get_message_by_name(message_type).ok_or(MessageHandlerError::MessageTypeNotFound)?;

        // Decode the message
        let decoded_message = DynamicMessage::decode(&message.body.content.as_bytes(), message_descriptor)
            .map_err(MessageHandlerError::DecodingError)?;

        Ok(decoded_message)
    }
}

fn main() {
    // The main function can contain any testing or demonstration code for your program.
}


#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_new_message_handler() {
        let handler = MessageHandler::new();
        assert!(handler.descriptor_pool.is_empty());
    }

    #[test]
    fn test_add_message_type() {
        let mut handler = MessageHandler::new();
        handler.add_message_type("test");

        assert!(handler.descriptor_pool.get_message_by_name("test").is_some());
    }

    #[test]
    fn test_deserialize_valid_message() {
        let mut handler = MessageHandler::new();
        handler.add_message_type("test");
        
        let message_json = r#"{
            "body": {
                "content": "test_content",
                "internal_metadata": {"message_schema_type": "test"},
                "topic": {"topic_id": "123", "channel_id": "456"}
            },
            "encryption": "none",
            "external_metadata": {
                "sender": "sender1",
                "recipient": "recipient1",
                "scheduled_time": "2023-06-24T15:30:00Z",
                "signature": "signature1"
            }
        }"#;

        let result = handler.deserialize(message_json);

        assert!(result.is_ok());
        let message = result.unwrap();
        assert_eq!(message.body.content, "test_content");
        assert_eq!(message.body.internal_metadata.message_schema_type, "test");
        assert_eq!(message.body.topic.topic_id, "123");
        assert_eq!(message.body.topic.channel_id, "456");
        assert_eq!(message.encryption, "none");
        assert_eq!(message.external_metadata.sender, "sender1");
        assert_eq!(message.external_metadata.recipient, "recipient1");
        assert_eq!(message.external_metadata.scheduled_time, "2023-06-24T15:30:00Z");
        assert_eq!(message.external_metadata.signature, "signature1");
    }

    #[test]
    fn test_deserialize_message_with_unknown_type() {
        let handler = MessageHandler::new();
        
        let message_json = r#"{
            "body": {
                "content": "test_content",
                "internal_metadata": {"message_schema_type": "unknown_type"},
                "topic": {"topic_id": "123", "channel_id": "456"}
            },
            "encryption": "none",
            "external_metadata": {
                "sender": "sender1",
                "recipient": "recipient1",
                "scheduled_time": "2023-06-24T15:30:00Z",
                "signature": "signature1"
            }
        }"#;

        let result = handler.deserialize(message_json);

        assert!(result.is_err());
        assert_eq!(result.unwrap_err(), MessageHandlerError::MessageTypeNotFound);
    }
}
